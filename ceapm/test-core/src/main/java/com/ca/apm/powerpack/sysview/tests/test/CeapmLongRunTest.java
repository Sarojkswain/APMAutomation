/*
 * Copyright (c) 2016 CA. All rights reserved.
 *
 * This software and all information contained therein is confidential and
 * proprietary and shall not be duplicated, used, disclosed or disseminated in
 * any way except as authorized by the applicable license agreement, without
 * the express written permission of CA. All authorized reproductions must be
 * marked with this language.
 *
 * EXCEPT AS SET FORTH IN THE APPLICABLE LICENSE AGREEMENT, TO THE EXTENT
 * PERMITTED BY APPLICABLE LAW, CA PROVIDES THIS SOFTWARE WITHOUT WARRANTY OF
 * ANY KIND, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT WILL CA BE
 * LIABLE TO THE END USER OR ANY THIRD PARTY FOR ANY LOSS OR DAMAGE, DIRECT OR
 * INDIRECT, FROM THE USE OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, LOST
 * PROFITS, BUSINESS INTERRUPTION, GOODWILL, OR LOST DATA, EVEN IF CA IS
 * EXPRESSLY ADVISED OF SUCH LOSS OR DAMAGE.
 */

package com.ca.apm.powerpack.sysview.tests.test;

import static org.testng.Assert.assertTrue;

import com.ca.apm.automation.action.flow.IFlowContext;
import com.ca.apm.automation.action.flow.em.DeployEMFlowContext;
import com.ca.apm.automation.action.flow.mainframe.sysview.SysviewGetMetricsFlow;
import com.ca.apm.automation.action.flow.mainframe.sysview.SysviewGetMetricsFlowContext;
import com.ca.apm.automation.action.test.ClwRunner;
import com.ca.apm.automation.utils.mainframe.Transactions;
import com.ca.apm.powerpack.sysview.tests.role.CeapmRole;
import com.ca.apm.powerpack.sysview.tests.role.CeapmRole.CeapmConfig;
import com.ca.apm.powerpack.sysview.tests.role.CeapmRole.CeapmJavaConfig;
import com.ca.apm.powerpack.sysview.tests.role.CicsTestDriverRole;
import com.ca.apm.powerpack.sysview.tests.role.WasAppRole;
import com.ca.apm.powerpack.sysview.tests.testbed.CeapmLongRunTestbed;
import com.ca.apm.powerpack.sysview.tools.cicstestdriver.xml.ConfigGenerator;
import com.ca.tas.test.TasTestNgTest;
import com.ca.tas.tests.annotations.Tas;
import com.ca.tas.tests.annotations.TestBed;
import com.ca.tas.type.SizeType;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * Long running test that runs current and GA version of agent in parallel and collects performance
 * data.
 *
 * Evaluation of the collected data is manual.
 *    Verify the test ran for expected time and evaluate reported error messages if any.
 *    Collect performance data from test logs (SYSVIEW METRICS, EM METRICS keywords)
 *    Inspect agent logs for errors.
 */
// TODO Better test summary, dump the performance data in format readily usable for analysis,
// automate detection of errors in logs.
public class CeapmLongRunTest extends TasTestNgTest {
    private static final Logger logger = LoggerFactory.getLogger(CeapmLongRunTest.class);
    /**
     * Base interval duration in minutes, used primarily by the metric gathering tasks.
     */
    private static final long INTERVAL_DURATION = TimeUnit.MINUTES.toMinutes(5);
    /**
     * Maximum duration of the test in milliseconds.
     */
    private static final long TEST_DURATION = TimeUnit.DAYS.toMillis(5);
    /**
     * Maximum number of successive errors generated by an individual task that are tolerated. A
     * higher number of errors would trigger the end of the test.
     */
    private static final int SUCCESSIVE_ERRORS_TOLERATED = 3;
    private static final CeapmConfig[] CEAPM_TASKS = {CeapmLongRunTestbed.CEAPM_BASE,
                                                     CeapmLongRunTestbed.CEAPM_TEST};
    private static final String[] CEAPM_JOB_NAMES = {CeapmLongRunTestbed.CEAPM_BASE.getTaskName(),
                                                     CeapmLongRunTestbed.CEAPM_TEST.getTaskName()};
    /** See {@link #shouldPause()} ()} */
    private static final File PAUSE_FILE = new File("C:\\automation\\pause");
    /** See {@link #shouldKeepRunning()} */
    private static final File STOP_FILE = new File("C:\\automation\\stop");

    private final String ctdDir = envProperties.getRolePropertyById(
        CeapmLongRunTestbed.CTD_ROLE_ID, CicsTestDriverRole.INSTALL_DIR_PROPERTY);

    private long testStartTime;
    private long testEndTime;
    private boolean keepRunning;
    private Collection<String> ctdDefinitions;

    private ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(5);
    private List<TestTask> tasks;

    private abstract class TestTask implements Runnable {
        private ScheduledFuture<?> future;

        long iteration;
        int totalErrors;
        int consecutiveErrors;

        abstract boolean runTask() throws Exception;

        abstract String getName();

        long getPeriod() {
            return TimeUnit.MINUTES.toMillis(INTERVAL_DURATION);
        }

        synchronized void start() {
            if (isRunning()) {
                return;
            }

            logger.info("Starting {}", getName());
            future = scheduler.scheduleAtFixedRate(this, 0, getPeriod(), TimeUnit.MILLISECONDS);
        }

        synchronized void stop() {
            if (isRunning()) {
                logger.info("Stopping {}", getName());
                future.cancel(false);
                future = null;
            }
        }

        public synchronized boolean isRunning() {
            return future != null && !future.isDone();
        }

        String getStatus() {
            if (!isRunning()) {
                return "finished";
            }

            final long delay = future.getDelay(TimeUnit.SECONDS);
            if (delay <= 0) {
                return "executing";
            } else if (shouldPause()) {
                return "paused";
            } else {
                return "next in ~ " + delay + "s";
            }
        }

        @Override
        public void run() {
            boolean error = false;
            try {
                if (!shouldKeepRunning()) {
                    stop();
                    return;
                }

                if (shouldPause()) {
                    logger.debug("Skipping {} execution due to pause", getName());
                    return;
                }

                ++iteration;
                logger.info("Executing {} ", getName());
                if (!runTask()) {
                    error = true;
                }
            } catch (Throwable e) {
                error = true;
                logger.error("Error executing {}", getName(), e);
            }

            if (error) {
                totalErrors++;
                consecutiveErrors++;
            } else {
                consecutiveErrors = 0;
            }

            logger.info("Finished iteration #{} of {}", iteration, getName());
        }
    }

    @BeforeTest
    public void initializeTest() throws Exception {
        ctdDefinitions = prepareCtdDefinitions();

        keepRunning = true;

        // Cleanup left-over stop file. Typically useful when doing repeated tas:launch executions.
        if (STOP_FILE.delete()) {
            logger.warn("Stop file ({}) was cleared during test initialization",
                STOP_FILE.getAbsolutePath());
        }
        // For "safety" reasons we don't clear the pause file, however we do issue a warning.
        if (PAUSE_FILE.exists()) {
            logger.warn("Pause file ({}) detected during test initialization",
                PAUSE_FILE.getAbsolutePath());
        }
    }

    @Tas(testBeds = @TestBed(name = CeapmLongRunTestbed.class,
        executeOn = CeapmLongRunTestbed.WIN_MACHINE_ID), size = SizeType.MAMMOTH)
    // TODO: Desired classification is FULL, but the current implementation limits us to ASSISTED.
    @Test(groups = TestClassification.ASSISTED)
    public void longRunTestJava6() throws Exception {
        longRunTest(CeapmJavaConfig.JVM6);
    }

    @Tas(testBeds = @TestBed(name = CeapmLongRunTestbed.class,
        executeOn = CeapmLongRunTestbed.WIN_MACHINE_ID), size = SizeType.MAMMOTH)
    @Test(groups = TestClassification.ASSISTED)
    public void longRunTestJava7() throws Exception {
        longRunTest(CeapmJavaConfig.JVM7);
    }

    @Tas(testBeds = @TestBed(name = CeapmLongRunTestbed.class,
        executeOn = CeapmLongRunTestbed.WIN_MACHINE_ID), size = SizeType.MAMMOTH)
    @Test(groups = TestClassification.ASSISTED)
    public void longRunTestJava8() throws Exception {
        longRunTest(CeapmJavaConfig.JVM8);
    }

    /**
     * Indicates whether the test should end.
     *
     * <p>The test ends after the maximum test execution time elapses ({@link #TEST_DURATION}), more
     * than {@link #SUCCESSIVE_ERRORS_TOLERATED} errors are detected in any one task, or the "stop"
     * file is detected on the machine ({@link #STOP_FILE}).
     *
     * <p>Once the conditions for stopping are met the method will always indicate that the
     * test should stop regardless of any subsequent changes in those conditions (cached using
     * the {@link #keepRunning} variable). This is so to accommodate the asynchronous nature of the
     * test tasks and to ensure consistency during test shutdown.
     *
     * @return {@code true} if the test should end, {@code false} otherwise.
     */
    private synchronized boolean shouldKeepRunning() {
        if (keepRunning) {
            if (System.currentTimeMillis() > testEndTime) {
                logger.info("Test end condition reached due to elapsed time");
                keepRunning = false;
            }

            for (TestTask task : tasks) {
                if (task.consecutiveErrors > SUCCESSIVE_ERRORS_TOLERATED) {
                    logger.info("Test end condition reached due to number of consecutive "
                        + "errors ({}) in {}", task.consecutiveErrors, task.getName());
                    keepRunning = false;
                }
            }

            if (STOP_FILE.exists()) {
                logger.info("Test end condition reached due to existence of the stop file: {}",
                    STOP_FILE.getAbsolutePath());
                keepRunning = false;
            }
        }

        return keepRunning;
    }

    /**
     * Indicates whether test tasks execution should pause.
     *
     * <p>You can pause test execution by putting a "pause" file ({@link #PAUSE_FILE}) on the
     * machine. The test tasks will not execute until the file is removed. This is intended to allow
     * execution of other tests that are sensitive to transactions generated by this test.
     *
     * @return {@code true} if task execution should pause, {@code false} otherwise.
     */
    private boolean shouldPause() {
        return PAUSE_FILE.exists();
    }

    /**
     * Returns the test elapsed time in a human-readable format.
     *
     * @return Elapsed time.
     */
    private String getElapsedTime() {
        long elapsed = System.currentTimeMillis() - testStartTime;

        final long days = TimeUnit.MILLISECONDS.toDays(elapsed);
        elapsed -= TimeUnit.DAYS.toMillis(days);

        final long hours = TimeUnit.MILLISECONDS.toHours(elapsed);
        elapsed -= TimeUnit.HOURS.toMillis(hours);

        final long minutes = TimeUnit.MILLISECONDS.toMinutes(elapsed);
        elapsed -= TimeUnit.MINUTES.toMillis(minutes);

        final long seconds = TimeUnit.MILLISECONDS.toSeconds(elapsed);

        return String.format("%02d days %02d:%02d:%02d", days, hours, minutes, seconds);
    }

    private void longRunTest(CeapmJavaConfig java) throws Exception {
        tasks = new ArrayList<>();

        // CTG-CICS
        tasks.add(new TestTask() {
            @Override
            boolean runTask() throws Exception {
                logger.debug("generating CTG-CICS transactions");
                for (String definition : ctdDefinitions) {
                    // Shortcut for a faster (clean) shutdown, and reaction to a pause request
                    if (!shouldKeepRunning() || shouldPause()) {
                        break;
                    }
                    Transactions.generateCtgCics(ctdDir, definition, true);
                }
                return true;
            }

            @Override
            long getPeriod() {
                return TimeUnit.MINUTES.toMillis(4);
            }

            @Override
            String getName() {
                return "CTG-CICS generator";
            }
        });

        // MQ-CICS
        tasks.add(new TestTask() {
            @Override
            boolean runTask() throws Exception {
                String wasContext =
                    envProperties.getRolePropertyById(CeapmLongRunTestbed.MQ_APP_ROLE_ID,
                        WasAppRole.APP_URL_ROOT_PROP);

                CeapmAppmapTest.postAndValidateCptjcaapp(wasContext, CeapmLongRunTestbed.MQ,
                    CeapmLongRunTestbed.CICS.getInputQueue(),
                    CeapmLongRunTestbed.CICS.getReplyQueue(), 5);
                return true;
            }

            @Override
            long getPeriod() {
                return TimeUnit.MINUTES.toMillis(1);
            }

            @Override
            String getName() {
                return "MQ-CICS generator";
            }
        });

        // Sysview metrics
        tasks.add(new TestTask() {
            @Override
            boolean runTask() throws Exception {
                try {
                    readSysviewMetrics();
                } catch (Throwable e) {
                    logger.error("Error collecting Sysview metrics", e);
                    return false;
                }

                return true;
            }

            @Override
            String getName() {
                return "Sysview metrics collector";
            }
        });

        // APM metrics
        tasks.add(new TestTask() {
            @Override
            boolean runTask() throws Exception {
                try {
                    if (!readEmMetrics()) {
                        return false;
                    }
                } catch (Throwable e) {
                    logger.error("Error collecting APM metrics", e);
                    return false;
                }

                return true;
            }

            @Override
            String getName() {
                return "APM metrics collector";
            }
        });

        logger.debug("Starting agents");
        for (CeapmConfig task : CEAPM_TASKS) {
            // TODO: This testbed uses a forwarder and thus we can't set verify=true below since
            // that verifies the agent startup by connecting to its SMF port
            CeapmRole.startAgent(aaClient, envProperties, task.getRole(),
                CeapmRole.getAgentJavaParameters(java), false);
        }

        testStartTime = System.currentTimeMillis();
        testEndTime = testStartTime + TEST_DURATION;

        // Start tasks
        logger.info("Starting test tasks");
        for (TestTask task : tasks) {
            task.start();
        }

        // Wait for the test to reach its end
        do {
            TimeUnit.SECONDS.sleep(30);

            logger.debug("Elapsed: {}", getElapsedTime());
            for (TestTask task : tasks) {
                logger.debug("{} ({}): {}", task.getName(), task.iteration, task.getStatus());
            }
        } while (shouldKeepRunning());
        // Indicate to tasks (that didn't notice yet) that they should stop executing.
        for (TestTask task : tasks) {
            task.stop();
        }
        scheduler.shutdown();
        logger.info("Test is finishing, waiting on task executions to end");
        scheduler.awaitTermination(INTERVAL_DURATION + 1, TimeUnit.MINUTES);
        logger.info("Test has finished, elapsed: {}", getElapsedTime());

        logger.info("Basic task execution statistics:");
        for (TestTask task :tasks) {
            logger.info(" * {} completed {} iterations with a total of {} total errors",
                task.getName(), task.iteration, task.totalErrors);
        }

        // Report overall test result
        for (TestTask task : tasks) {
            assertTrue(task.consecutiveErrors <= SUCCESSIVE_ERRORS_TOLERATED,
                task.getName() + " accumulated " + task.consecutiveErrors + " consecutive errors");
        }
    }

    private Collection<String> prepareCtdDefinitions() throws Exception {
        logger.debug("Generating CTD test definitions");

        List<String> ctdDefinitions = new ArrayList<>();
        final String ctgUri = "tcp://localhost";
        final String mappingPath = ctdDir + "\\xml\\mapping.xml";
        final String ipicId = CeapmLongRunTestbed.CICS.getIpicId();

        // DB2 calls
        String definitionName = "generated_DB2_localhost.xml";
        new ConfigGenerator(ctgUri, 2006, ipicId, 1, 1_000_000, 1, null)
            .addProgramCall("ECIDB2D", null)
            .generate(mappingPath, ctdDir + "\\xml\\" + definitionName);
        ctdDefinitions.add(definitionName);

        // SLEEP03 calls
        definitionName = "generated_SLP_localhost.xml";
        new ConfigGenerator(ctgUri, 2006, ipicId, 1, 1_000_000, 1, null)
            .addProgramCall("SLEEP03", null)
            .generate(mappingPath, ctdDir + "\\xml\\" + definitionName);
        ctdDefinitions.add(definitionName);

        // Calls that fully excercise the Programs transaction trace
        definitionName = "generated_ProgramsTT_localhost.xml";
        new ConfigGenerator(ctgUri, 2006, ipicId, 1, 1_000_000, 1, null)
            .addProgramCall("CALLPROG", "["
                + "{program:CALLPRO1, count:2, subActions:[{delay:1000}]},"
                + "{program:WB43F6KO},"
                + "{program:D95HT8MP, sysId:NONE},"
                + "{program:CALLPRO2, subActions:[{delay:7000}, {abend:AEY0}]}"
                + "]")
            .addProgramCall("CALLPROG", "["
                + "{program:CALLPRO2, subActions:[{delay:9000}, {abend:AEY1}]}"
                + "]")
            .generate(mappingPath, ctdDir + "\\xml\\" + definitionName);
        ctdDefinitions.add(definitionName);

        return ctdDefinitions;
    }

    private void readSysviewMetrics() throws IOException {
        logger.debug("collecting Sysview metrics");

        List<String> jobs = new ArrayList<>();
        for (String job : CEAPM_JOB_NAMES) {
            jobs.add("jobname eq " + job);
        }
        String queryAgents =
            "actsum current interval " + INTERVAL_DURATION + "; select "
                + StringUtils.join(jobs, " or ");
        IFlowContext ctx =
            new SysviewGetMetricsFlowContext.Builder(queryAgents)
                .loadlib(CeapmLongRunTestbed.SYSVIEW.getLoadlib())
                .keyName("Jobname")
                .keyValues(CEAPM_JOB_NAMES)
                .columns("CPUTime", "IORate", "RealStg").build();

        runFlowByMachineId(CeapmLongRunTestbed.MF_MACHINE_ID, SysviewGetMetricsFlow.class, ctx);
    }

    private boolean readEmMetrics() throws IOException, InterruptedException {
        logger.debug("collecting EM metrics");

        final ClwRunner clwBase =
            getClwRemoteRunner(CeapmLongRunTestbed.EM_ROLE_ID, CeapmLongRunTestbed.EM_BASE_ID);
        final ClwRunner clwTest =
            getClwRemoteRunner(CeapmLongRunTestbed.EM_ROLE_ID, CeapmLongRunTestbed.EM_ROLE_ID);
        final String clwCommand =
            "get historical data from agents matching (.*Cross-Enterprise.*) and metrics matching"
                + " (GC Heap:Bytes In Use) for past " + INTERVAL_DURATION + " minutes with "
                + "frequency of " + TimeUnit.MINUTES.toSeconds(INTERVAL_DURATION) + " seconds";

        // collecting metrics from both EMs
        List<String> clwOutputBase = clwBase.runClw(clwCommand);
        List<String> clwOutputTest = clwTest.runClw(clwCommand);

        // logging current GC heap values
        boolean baseAgentOk = clwOutputBase.size() > 2;
        boolean testAgentOk = clwOutputTest.size() > 2;
        if (baseAgentOk && testAgentOk) {
            String[] valBase = clwOutputBase.get(2).split(",");
            String[] valTest = clwOutputTest.get(2).split(",");
            logger.info("EM METRICS: " + valBase[13] + ", " + valTest[13]);
            return true;
        } else {
            String msgAgents =
                (!baseAgentOk ? "base" : "") + (!baseAgentOk && !testAgentOk ? " and " : "")
                    + (!testAgentOk ? "test" : "") + " agent";
            logger.error("EM metrics data not received for " + msgAgents);
            return false;
        }
    }

    private ClwRunner getClwRemoteRunner(String localEmRoleId, String targetEmRoleId) {
        String host = envProperties.getMachineHostnameByRoleId(targetEmRoleId);
        int port =
            Integer.parseInt(envProperties.getRolePropertyById(targetEmRoleId,
                DeployEMFlowContext.ENV_EM_PORT));
        String emLibDir =
            envProperties.getRolePropertyById(localEmRoleId, DeployEMFlowContext.ENV_EM_LIB_DIR);
        ClwRunner.Builder clwBuilder = new ClwRunner.Builder();
        clwBuilder.host(host).port(port).clwWorkStationDir(emLibDir);

        return clwBuilder.build();
    }
}
